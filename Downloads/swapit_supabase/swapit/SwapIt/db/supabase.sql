-- ==== CORE TABLES ===========================================================
create table if not exists profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  name text not null default 'New User',
  avatar_url text,
  role text not null default 'member',
  created_at timestamp with time zone default now()
);

create table if not exists categories (
  id serial primary key,
  name text unique not null
);

insert into categories (name)
  values ('Tools'),('Electronics'),('Home & Garden'),('Sports'),('Books'),('Other')
on conflict do nothing;

create table if not exists items (
  id bigint generated by default as identity primary key,
  owner_id uuid not null references auth.users(id) on delete cascade,
  category_id int references categories(id) on delete set null,
  title text not null,
  description text,
  rules text,
  city text,
  price_per_day numeric(10,2) default 0,
  is_free boolean default false,
  image_url text,
  available_from date,
  available_to date,
  status text not null default 'active',
  created_at timestamp with time zone default now()
);

create table if not exists borrow_requests (
  id bigint generated by default as identity primary key,
  item_id bigint not null references items(id) on delete cascade,
  lender_id uuid not null references auth.users(id) on delete cascade,
  borrower_id uuid not null references auth.users(id) on delete cascade,
  start_date date not null,
  end_date date not null,
  note text,
  status text not null default 'pending',
  created_at timestamp with time zone default now()
);

create table if not exists reviews (
  id bigint generated by default as identity primary key,
  request_id bigint not null references borrow_requests(id) on delete cascade,
  reviewer_id uuid not null references auth.users(id) on delete cascade,
  reviewee_id uuid not null references auth.users(id) on delete cascade,
  rating int not null check (rating between 1 and 5),
  comment text,
  created_at timestamp with time zone default now()
);

create table if not exists messages (
  id bigint generated by default as identity primary key,
  request_id bigint not null references borrow_requests(id) on delete cascade,
  sender_id uuid not null references auth.users(id) on delete cascade,
  body text not null,
  created_at timestamp with time zone default now()
);

create table if not exists notifications (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  kind text not null,
  content text not null,
  is_read boolean default false,
  created_at timestamp with time zone default now()
);

create or replace view user_ratings as
select reviewee_id as user_id,
       avg(rating)::numeric(3,2) as avg_rating,
       count(*)::int as ratings_count
from reviews
group by reviewee_id;

create or replace function handle_new_user()
returns trigger language plpgsql security definer as $$
begin
  insert into profiles (id, name)
  values (new.id, coalesce(new.raw_user_meta_data->>'name','New User'));
  return new;
end; $$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute function handle_new_user();

alter table profiles enable row level security;
alter table items enable row level security;
alter table borrow_requests enable row level security;
alter table reviews enable row level security;
alter table messages enable row level security;
alter table notifications enable row level security;

create policy "read profiles" on profiles for select using (true);
create policy "update own profile" on profiles for update using (auth.uid() = id);

create policy "read items" on items for select using (status = 'active' or owner_id = auth.uid());
create policy "insert items" on items for insert with check (owner_id = auth.uid());
create policy "update own items" on items for update using (owner_id = auth.uid());
create policy "delete own items" on items for delete using (owner_id = auth.uid());

create policy "insert request (borrower only)" on borrow_requests for insert with check (borrower_id = auth.uid());
create policy "select own requests" on borrow_requests for select using (borrower_id = auth.uid() or lender_id = auth.uid());
create policy "update by lender to approve/decline" on borrow_requests for update using (lender_id = auth.uid());
create policy "update by parties to active/returned" on borrow_requests for update using (borrower_id = auth.uid() or lender_id = auth.uid());

create policy "insert reviews by parties" on reviews for insert with check (reviewer_id = auth.uid());
create policy "select reviews public" on reviews for select using (true);

create policy "insert messages (party)" on messages for insert with check (sender_id = auth.uid());
create policy "select messages (party)" on messages for select using (
  exists (select 1 from borrow_requests r where r.id = request_id and (r.borrower_id = auth.uid() or r.lender_id = auth.uid()))
);

create policy "select own notifications" on notifications for select using (user_id = auth.uid());
